## Debugging issues with OpenJDK

Sometimes it is necessry to investigate a crash in native code.
If the problem is not in an external library, it is likely that something
went wrong inside the JVM. In that case, the following steps might help
you with diagnosing the problem:


 * Try to reproduce it on a more powerful machine (like with ARMv7 CPU).
   If it reproduces, continue testing on this machine.
   Good machines for this include newer Raspberry Pis and Odroid SBCs.
 * Try to reproduce it using QEMU (e.g. in the Docker packaging container).
   If it reproduces, continue there.
 * Somehow get the debug symbols for the Java runtime. The
   `jri-11-ev3-dbgsym` package from the repositories should suffice.
   Alternatively, run a manual build to get a `fastdebug` or `slowdebug`
   build (value of `JDKDEBUG` environment variable) and try to reproduce
   the issue there.
     - Optionally, you can also build the hsdis native disassembler for
       diagnosing JIT compiler issues. However, I have not tried this.
       It should give the ability to print JIT-generated ASM code;
       however, it is also possible to disassemble it directly from GDB.
 * Try to diagnose the issue with GDB - either by investigating the
   core dump generated by the crash (to enable them, run
   `ulimit -c unlimited`) or by triggering it in GDB. Another way is to
   start the GDB only once the crash happens. See [here][jvm_gdb],
   for more details, however I think the inner gdb command should be `gdb -p %p`.
 * Try to discover the cause of the bug by walking through
   the stack trace and the source code.

[jvm_gdb]: https://neugens.wordpress.com/2015/02/26/debugging-the-jdk-with-gdb/
