## Packaging, signing and uploading for ev3dev

### First-time setup
This step is common all following steps (packaging, signing, uploading).

 1. Install and run preferably a Debian-based Linux distribution.
    If you are not running Linux on your hardware, then it should be
    possible to install Linux in a virtual machine. I recommend running
    Xubuntu 18.04.
 2. Install Docker: [Get Docker Engine - Community for Ubuntu](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
 3. Install `gnupg`, `openssh-client`, `devscripts`, `qemu-user-static`
    and `binfmt-support` packages using APT.
    - `gnupg` is the GNU Privacy Guard, a set of utilities for
      (among other things) signing and verifying digital signatures
      on files (e.g. Debian packages).
    - `openssh-client` is the Secure Shell client. Its `sftp` command
      can used for uploading the packages to the repository server.
    - `devscripts` contains (among other programs) the `debsign` utility
      which is later used for signing the Debian package upload request.
    - `qemu-user-static` and `binfmt-support` together allow running
      ARM Linux binaries on x86 Linux system. This is necessary for the
      repackaging process as it involves locally running the Debian
      system that the EV3 uses.
 4. To upload the package to the repository sever, you will need
    a SSH keypair. See [GitHub help][sshkey] for how to generate a SSH
    key if you do not have one.
 5. You will also need to have a GPG keypair so that you can sign
    the generated packages (more on this later).
    The process is [covered on GitHub][gpgkey] as well.
 6. Now that you have the SSH & GPG keys, you need to submit them to
    ev3dev maintainers in order for them to become trusted for uploading.
    To do this, send the public halves of these keys to David Lechner
    &lt;david at lechnology dot com&gt;. A good way to
    complement this could be an issue on ev3dev GitHub, as that way your
    GitHub identity will be linked to the origin of the keys. Include your
    email address (which should be the same as the one in the GPG key)
    in the request. The ev3dev maintainer will then (hopefully) add the
    keys to the repository server.
 7. You will also need to ask the ev3dev maintainers for becoming
    a maintainer of the package you want to upload. This will give you
    the permission on the repository server to overwrite the existing package.
 8. Build locally the Docker container for the repackaging process.
    You will need to have a separate container image for each Debian release
    that you want to target. First, you will need to download the
    openjdk-ev3 repository and go into into it inside terminal.
    Then, in order to build packages for `ev3dev-stretch`, run the following command:
    ```sh
    sudo docker build \
        --tag ev3dev-lang-java:jdk-stretch-package \
        --build-arg DEBIAN_RELEASE=stretch \
        <repo>/packaging
    ```
    For `ev3dev-buster` the following command will do it:
    ```sh
    sudo docker build \
        --tag ev3dev-lang-java:jdk-buster-package \
        --build-arg DEBIAN_RELEASE=buster \
        <repo>/packaging
    ```

[sshkey]: https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
[gpgkey]: https://help.github.com/en/github/authenticating-to-github/generating-a-new-gpg-key

### Packaging

#### Overview
While it is certainly possible, using the `jri-ev3.tar.gz` archive
directly is a bit cumbersome. To make the installation easier to handle,
it is necessary to repackage Java to the Debian package format. This
also enables easy preinstallation into the ev3dev EV3 image via APT.

The repackaging environment is once again provided by a Docker image.
There is a small caveat though. AFAIK due to a limitation of the debian
`debuild` utility, it is necessary to build the package on the same
Debian version and architecture as the one the package needs to target.
This is not a problem - thanks to the `qemu-user-static` package,
it is possible to run EV3 armel binaries on x86.

The repackaging process inside the container starts with a small wrapper
script (`packaging.sh`). It parses the `metadata` file generated by the
JDK build and it fills templating placeholders in the Debian package
definition. It also takes in a debian package revision number - this
is a necessary for having the possibility of uploading a new package
with the same java version as the previous one.
Finally, it calls `debuild` package building utility to build the package.

The `packaging/debian` subdirectory in the repository contains the
template package definition and build scripts. These are processed
by `debuild`. The `rules` script controls the process; it copies the
contents of the JRI archive to the appropriate places for a debian
Java package. However most of the heavy lifting is done by `debhelper`
scripts called automatically from the `rules` script.

The repackaging procedure produces five files overall, but only three
of them are useful. Those are the debian package, its debugging symbols
package and an unsigned package upload request. This package upload request
can be signed with GPG and after that it can to be uploaded together
with the packages to the ev3dev repository.

#### Steps
This operation is not automated, it is necessary to follow it each time
a new package version is to be released.
 1. Download and move the `jri-ev3.tar.gz` and `metadata` files from
    the AdoptOpenJDK Jenkins to an empty directory somewhere on the host.
    Then, run `chmod -R 777 <path to the directory>` to make the directory
    accessible to all users (including the UID 1001 in the container).
    This directory will be used as a working space of the container.
 2. Run the repackaging process. The command again differs between the
    distro releases. You will also need to provide the `JAVA_PACKAGE_REVISION`
    environment variable. This variable sets the suffix placed after
    the JDK version number.

    - Conceptual note. This is about the version number that the Debian
      package will contain. Let's analyze the following version number:
      `11.0.6~10-2`
      - `11.0.6` is the "big" release number
      - `10` is the “revision” number (not revision hash) of the SCM tag
      - `2` is the packaging suffix intended for package maintainers.

    - The packaging suffix is useful for fixing various issues not directly caused by OpenJDK. For example, if you want to immediately add a new JMOD to the JRI image, you can release a new package with the same Java version but an incremented packaging version.

    - **BEWARE**: if you are building packages for Stretch and Buster
      together, use a different revision for each package. If you create
      both packages with the same revision, upload of the second package
      will fail because it will conflict with the first uploaded package.

    Command for Stretch:
    ```sh
    sudo docker run \
        --rm \
        --interactive \
        --tty \
        --volume <path to the directory with JRI>:/build \
        --env "JAVA_PACKAGE_REVISION=-1" \
        ev3dev-lang-java:jdk-stretch-package
    ```
    Command for Buster:
    ```sh
    sudo docker run \
        --rm \
        --interactive
        --tty \
        --volume <path to the directory with JRI>:/build \
        --env "JAVA_PACKAGE_REVISION=-2" \
        ev3dev-lang-java:jdk-buster-package
    ```
 3. Run `chmod -R 777 <path to the directory>` again on the workspace.
    This will override the permissions coming from the container,
    eliminating errors stemming from UID mismatch between on-host user
    and in-container user.
 4. Enter the `<path to the directory>/pkg` subdirectory. This is where
    the debian package was generated. However, not all files are necesary.
    Delete all files that do not end with `.deb` or `.changes`.

### Signing the packages

#### Overview
In the Debian world, trust in the package integrity is ensured through
GPG signatures. The root of trust is the repository key with which a
so called `Release` file is signed. This file then verifies packages
lists (via hashes), which in turn verify the packages (again via hashes).
The Release private key resides on the repository server and it is not
usually manipulated manually. Instead it is managed automatically
by a repository software. Ev3dev is using Reprepro for this.

In order to prevent unauthorized package uploads, the repository software
needs to have a list of keys that it trusts. When a maintainer wants to
upload a new package, they upload the packages itself (unsigned .deb files)
and a package upload request (signed .changes file). The upload request
contains hashes of the packages itself and this way it ensures their
integrity and their trustworthiness.

#### Steps
Provided that you have the devscripts debian package installed and the
GPG key set up, you can sign the package upload request by running:
```sh
debsign jri-11-ev3_11.0.4~11-1_armel.changes
```

### Uploading

#### Overview
Ev3dev maintainers need to have a way to send new packages to the
repository software. This is handled via a SFTP server running at
`reprepro.ev3dev.org` coupled with a file watcher. After a maintainer
uploads a `.changes` file to a special directory, the server will take
the associated files. It will verify their signature and uploader
permissions and if all checks pass, it will put the packages into
the repository ifself.

#### Steps
For this operation, you can either use the `sftp` command line client or
any other SFTP client like FileZilla.

 1. Change the extension of the `.changes` file to a `.tmp` file.
    Without doing this, the repository software will detect the upload
    attempt too soon the the process will fail.
    ```
    $ mv <name>.changes <name>.tmp
    ```
 2. Open a SFTP client and connect to `ev3dev-upload@reprepro.ev3dev.org`.
    ```
    $ sftp ev3dev-upload@reprepro.ev3dev.org
    ```
 3. Go to the `/debian/` directory on the SFTP server.
    ```
    sftp> cd debian
    ```
 4. Upload the JRI packages (2× `.deb`) and the upload request (`.tmp`)
    to the directory.
    ```
    sftp> put <pkg1>.deb
    sftp> put <pkg2>.deb
    sftp> put <name>.tmp
    ```
 5. Rename the `.tmp` file to `.changes` file **remotely**. By renaming
    the file after upload completes, the repository software sees the
    complete upload request and the request can succeed.
    ```
    sftp> rename <name>.tmp <name>.changes
    ```
 6. Leave the SFTP session.
    ```
    sftp> exit
    ```
 7. Check your email inbox. After a few seconds, you should receive an
    email either confirming the success of the upload or describing
    the error that caused it to fail.
 8. The package should now be present in the repository. To verify this,
    download [stretch](http://archive.ev3dev.org/debian/dists/stretch/main/binary-armel/Packages)
    or [buster](http://archive.ev3dev.org/debian/dists/buster/main/binary-armel/Packages)
    package lists and look for the JRI package version.
